<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture Interactive Tree - Prototype</title>
    <style>
      :root {
        --bg: #070a10;
        --panel: rgba(17, 22, 33, 0.78);
        --panel-border: rgba(255, 255, 255, 0.09);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --accent: #50e3c2;
        --danger: #ff5f6d;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(1200px 800px at 30% 20%, #101a29, var(--bg));
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple Color Emoji", "Segoe UI Emoji";
        overflow: hidden;
      }

      #threeCanvas {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: block;
      }

      #ui {
        position: fixed;
        top: 12px;
        left: 12px;
        width: min(420px, calc(100vw - 24px));
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 14px;
        padding: 14px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
      }

      #ui h1 {
        font-size: 14px;
        margin: 0 0 8px 0;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 12px;
      }

      .btn,
      .file {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--panel-border);
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        cursor: pointer;
        user-select: none;
        text-decoration: none;
        transition: transform 120ms ease, background 120ms ease;
      }

      .btn:active,
      .file:active {
        transform: translateY(1px);
      }

      .btn.primary {
        border-color: rgba(80, 227, 194, 0.35);
        background: rgba(80, 227, 194, 0.12);
      }

      .file input {
        display: none;
      }

      .statusGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 12px;
      }

      .statusGrid strong {
        color: var(--text);
        font-weight: 600;
      }

      #errorBox {
        display: none;
        margin-top: 10px;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid rgba(255, 95, 109, 0.35);
        background: rgba(255, 95, 109, 0.12);
        color: rgba(255, 255, 255, 0.92);
        font-size: 12px;
        line-height: 1.4;
        white-space: pre-wrap;
      }

      #webcamPreview {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        border-radius: 14px;
        overflow: hidden;
        border: 1px solid var(--panel-border);
        background: rgba(255, 255, 255, 0.04);
      }

      #webcam,
      #handCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      #webcam {
        transform: scaleX(-1);
        object-fit: cover;
        opacity: 0.95;
      }

      #handCanvas {
        pointer-events: none;
      }

      #footerHint {
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.4;
      }

      #footerHint code {
        color: rgba(255, 255, 255, 0.86);
        background: rgba(255, 255, 255, 0.06);
        padding: 2px 6px;
        border-radius: 8px;
      }

      @media (max-width: 640px) {
        #ui {
          left: 10px;
          right: 10px;
          width: auto;
        }

        .controls {
          grid-template-columns: 1fr;
        }

        .statusGrid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>

  <body>
    <canvas id="threeCanvas"></canvas>

    <div id="ui" role="dialog" aria-label="Controls">
      <h1>THREE.JS + MediaPipe Hands (Init)</h1>

      <div class="controls">
        <label class="file" title="Upload a photo">
          <input id="photoInput" type="file" accept="image/*" />
          <span>Upload Photo</span>
        </label>
        <button id="startWebcamBtn" class="btn primary" type="button">Start Webcam</button>
      </div>

      <div class="statusGrid">
        <div>Hand: <strong id="handStatus">idle</strong></div>
        <div>Gesture: <strong id="gestureStatus">-</strong></div>
        <div>State: <strong id="stateStatus">-</strong></div>
        <div>FPS: <strong id="fpsStatus">-</strong></div>
      </div>

      <div id="webcamPreview" aria-label="Webcam preview">
        <video id="webcam" playsinline muted></video>
        <canvas id="handCanvas"></canvas>
      </div>

      <div id="errorBox"></div>

      <div id="footerHint">
        Tips: run via <code>http://localhost</code> (webcam requires secure context). Gestures:
        <code>fist</code> → CLOSED, <code>open palm</code> → OPEN, <code>pinch</code> → ZOOM.
      </div>
    </div>

    <!-- MediaPipe Hands (global) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>

    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

      const $ = (id) => /** @type {HTMLElement} */ (document.getElementById(id));

      const dom = {
        threeCanvas: /** @type {HTMLCanvasElement} */ ($("threeCanvas")),
        photoInput: /** @type {HTMLInputElement} */ ($("photoInput")),
        startWebcamBtn: /** @type {HTMLButtonElement} */ ($("startWebcamBtn")),
        handStatus: $("handStatus"),
        gestureStatus: $("gestureStatus"),
        stateStatus: $("stateStatus"),
        fpsStatus: $("fpsStatus"),
        errorBox: $("errorBox"),
        webcam: /** @type {HTMLVideoElement} */ ($("webcam")),
        handCanvas: /** @type {HTMLCanvasElement} */ ($("handCanvas")),
      };

      const AppState = Object.freeze({
        CLOSED: "CLOSED",
        OPEN: "OPEN",
        ZOOM: "ZOOM",
      });

      const state = {
        appState: AppState.OPEN,
        lastGesture: "-",
        handPresent: false,
        pinchStrength: 0,
        handRotation: 0,
        handPos: { x: 0.5, y: 0.5 },
      };

      function setError(message) {
        if (!message) {
          dom.errorBox.style.display = "none";
          dom.errorBox.textContent = "";
          return;
        }
        dom.errorBox.style.display = "block";
        dom.errorBox.textContent = message;
      }

      // -----------------------------
      // THREE.js scene initialization
      // -----------------------------
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x070a10, 6, 18);

      const camera = new THREE.PerspectiveCamera(
        55,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 1.5, 4.2);
      camera.lookAt(0, 1.2, 0);

      const renderer = new THREE.WebGLRenderer({
        canvas: dom.threeCanvas,
        antialias: true,
        powerPreference: "high-performance",
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x070a10, 1);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const ambient = new THREE.AmbientLight(0xffffff, 0.45);
      scene.add(ambient);

      const spot = new THREE.SpotLight(0xffffff, 1.1, 30, Math.PI * 0.22, 0.35, 1.2);
      spot.position.set(2.8, 7.2, 4.2);
      spot.castShadow = true;
      spot.shadow.mapSize.width = 1024;
      spot.shadow.mapSize.height = 1024;
      spot.shadow.bias = -0.00015;
      scene.add(spot);

      const point = new THREE.PointLight(0x50e3c2, 0.9, 20);
      point.position.set(-2.6, 2.2, 2.2);
      scene.add(point);

      const groundGeo = new THREE.PlaneGeometry(40, 40);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x0a0e16,
        roughness: 1,
        metalness: 0,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      // Placeholder “tree” group (for later particle/geometry buildout)
      const treeGroup = new THREE.Group();
      treeGroup.position.set(0, 0, 0);
      scene.add(treeGroup);

      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.18, 0.55, 20),
        new THREE.MeshStandardMaterial({ color: 0x5d3b26, roughness: 1 })
      );
      trunk.position.y = 0.28;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      treeGroup.add(trunk);

      const foliage = new THREE.Mesh(
        new THREE.ConeGeometry(0.95, 1.7, 36),
        new THREE.MeshStandardMaterial({ color: 0x0f7b4c, roughness: 0.8 })
      );
      foliage.position.y = 1.25;
      foliage.castShadow = true;
      foliage.receiveShadow = true;
      treeGroup.add(foliage);

      // Photo plane (uploaded image)
      let photoMesh = null;
      let photoTexture = null;

      function ensurePhotoMesh() {
        if (photoMesh) return;
        const geo = new THREE.PlaneGeometry(1.8, 1.2);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        photoMesh = new THREE.Mesh(geo, mat);
        photoMesh.position.set(0, 1.3, -1.2);
        treeGroup.add(photoMesh);
      }

      function setPhotoTexture(texture) {
        ensurePhotoMesh();
        if (photoMesh.material.map) photoMesh.material.map.dispose?.();
        photoMesh.material.map = texture;
        photoMesh.material.needsUpdate = true;
      }

      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }
      window.addEventListener("resize", onResize);

      // -----------------------------
      // Basic performance monitor
      // -----------------------------
      let lastFrameAt = performance.now();
      let fpsSma = 60;
      let fpsLastUpdateAt = performance.now();

      function updateFps(now) {
        const dt = Math.max(1, now - lastFrameAt);
        lastFrameAt = now;
        const fps = 1000 / dt;
        fpsSma = fpsSma * 0.9 + fps * 0.1;
        if (now - fpsLastUpdateAt > 350) {
          dom.fpsStatus.textContent = fpsSma.toFixed(0);
          fpsLastUpdateAt = now;
        }
      }

      // -----------------------------
      // MediaPipe Hands integration
      // -----------------------------
      /** @type {any} */
      let hands = null;
      /** @type {any} */
      let cameraFeed = null;

      function setUiFromState() {
        dom.handStatus.textContent = state.handPresent ? "tracking" : "no hand";
        dom.gestureStatus.textContent = state.lastGesture;
        dom.stateStatus.textContent = state.appState;
      }

      function dist2(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }

      function clamp01(v) {
        return Math.max(0, Math.min(1, v));
      }

      function classifyGesture(landmarks) {
        const wrist = landmarks[0];
        const indexMcp = landmarks[5];
        const middleMcp = landmarks[9];

        const handSize = Math.max(0.001, dist2(wrist, middleMcp));

        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const pinchDist = dist2(thumbTip, indexTip);
        const pinch = pinchDist < handSize * 0.35;
        const pinchStrength = clamp01(1 - pinchDist / (handSize * 0.55));

        const pinchCenter = {
          x: (thumbTip.x + indexTip.x) / 2,
          y: (thumbTip.y + indexTip.y) / 2,
        };

        const posSrc = pinch ? pinchCenter : middleMcp;
        const position = {
          // Mirror to match the UI preview (video is mirrored via CSS)
          x: 1 - posSrc.x,
          y: posSrc.y,
        };

        const fingerDefs = [
          { name: "index", tip: 8, pip: 6 },
          { name: "middle", tip: 12, pip: 10 },
          { name: "ring", tip: 16, pip: 14 },
          { name: "pinky", tip: 20, pip: 18 },
        ];

        let extendedCount = 0;
        for (const f of fingerDefs) {
          const tip = landmarks[f.tip];
          const pip = landmarks[f.pip];
          const tipD = dist2(wrist, tip);
          const pipD = dist2(wrist, pip);
          if (tipD > pipD + handSize * 0.12) extendedCount += 1;
        }

        const openPalm = extendedCount >= 3 && !pinch;
        const fist = extendedCount <= 1 && !pinch;

        const dx = indexMcp.x - wrist.x;
        const dy = indexMcp.y - wrist.y;
        const rotation = Math.atan2(dy, dx);

        let name = "unknown";
        if (pinch) name = "pinch";
        else if (openPalm) name = "open_palm";
        else if (fist) name = "fist";

        return {
          name,
          pinch,
          pinchStrength,
          openPalm,
          fist,
          rotation,
          position,
        };
      }

      function updateStateFromGesture(gesture) {
        if (!gesture) {
          state.handPresent = false;
          state.lastGesture = "-";
          state.pinchStrength = 0;
          state.handPos = { x: 0.5, y: 0.5 };
          return;
        }

        state.handPresent = true;
        state.lastGesture = gesture.name;
        state.pinchStrength = gesture.pinchStrength;
        state.handRotation = gesture.rotation;
        state.handPos = gesture.position;

        if (gesture.pinch) state.appState = AppState.ZOOM;
        else if (gesture.openPalm) state.appState = AppState.OPEN;
        else if (gesture.fist) state.appState = AppState.CLOSED;
      }

      function resizeHandCanvas() {
        const rect = dom.handCanvas.getBoundingClientRect();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        dom.handCanvas.width = Math.round(rect.width * dpr);
        dom.handCanvas.height = Math.round(rect.height * dpr);
      }

      const handCtx = dom.handCanvas.getContext("2d");

      function drawHands(results) {
        if (!handCtx) return;

        resizeHandCanvas();
        const { width, height } = dom.handCanvas;
        handCtx.save();
        handCtx.clearRect(0, 0, width, height);

        // Mirror to match video
        handCtx.translate(width, 0);
        handCtx.scale(-1, 1);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const landmarks = results.multiHandLandmarks[0];
          window.drawConnectors(handCtx, landmarks, window.HAND_CONNECTIONS, {
            color: "rgba(80, 227, 194, 0.95)",
            lineWidth: 3,
          });
          window.drawLandmarks(handCtx, landmarks, {
            color: "rgba(255,255,255,0.9)",
            lineWidth: 1,
            radius: 2,
          });
        }

        handCtx.restore();
      }

      async function initHands() {
        if (!window.Hands || !window.Camera) {
          throw new Error("MediaPipe libraries failed to load. Check network/CSP settings.");
        }

        hands = new window.Hands({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.7,
        });

        hands.onResults((results) => {
          drawHands(results);

          const landmarks = results.multiHandLandmarks?.[0];
          const gesture = landmarks ? classifyGesture(landmarks) : null;
          updateStateFromGesture(gesture);
          setUiFromState();
        });

        dom.webcam.setAttribute("autoplay", "true");
        dom.webcam.setAttribute("playsinline", "true");
        dom.webcam.muted = true;

        cameraFeed = new window.Camera(dom.webcam, {
          onFrame: async () => {
            await hands.send({ image: dom.webcam });
          },
          width: 1280,
          height: 720,
        });

        await cameraFeed.start();
      }

      dom.startWebcamBtn.addEventListener("click", async () => {
        setError("");
        dom.startWebcamBtn.disabled = true;
        dom.startWebcamBtn.textContent = "Starting...";
        try {
          await initHands();
          dom.startWebcamBtn.textContent = "Webcam Running";
        } catch (err) {
          dom.startWebcamBtn.disabled = false;
          dom.startWebcamBtn.textContent = "Start Webcam";
          setError(
            `Failed to start webcam/hand tracking.\n\n${
              err instanceof Error ? err.message : String(err)
            }\n\nMake sure you're running on https or http://localhost and have granted camera permission.`
          );
        }
      });

      // -----------------------------
      // Photo upload handling
      // -----------------------------
      dom.photoInput.addEventListener("change", () => {
        setError("");
        const file = dom.photoInput.files?.[0];
        if (!file) return;
        if (!file.type.startsWith("image/")) {
          setError("Please upload an image file.");
          return;
        }

        const reader = new FileReader();
        reader.onload = () => {
          const dataUrl = typeof reader.result === "string" ? reader.result : "";
          if (!dataUrl) return;

          const loader = new THREE.TextureLoader();
          loader.load(
            dataUrl,
            (texture) => {
              texture.colorSpace = THREE.SRGBColorSpace;
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.generateMipmaps = false;

              if (photoTexture) photoTexture.dispose();
              photoTexture = texture;
              setPhotoTexture(texture);
            },
            undefined,
            () => {
              setError("Failed to load image texture.");
            }
          );
        };
        reader.readAsDataURL(file);
      });

      // -----------------------------
      // Render loop + basic interaction mapping
      // -----------------------------
      const clock = new THREE.Clock();

      function animate(now) {
        requestAnimationFrame(animate);
        updateFps(now);

        const dt = clock.getDelta();

        const baseScale =
          state.appState === AppState.CLOSED
            ? 0.72
            : state.appState === AppState.ZOOM
              ? 1.05 + state.pinchStrength * 0.55
              : 1.0;

        const currentScale = treeGroup.scale.x;
        const nextScale = THREE.MathUtils.lerp(
          currentScale,
          baseScale,
          1 - Math.pow(0.001, dt)
        );
        treeGroup.scale.setScalar(nextScale);

        // Pinch in ZOOM state doubles as a basic “grab/drag” interaction.
        const grabbing = state.handPresent && state.appState === AppState.ZOOM;
        const dragRangeX = 1.55;
        const targetX = grabbing
          ? THREE.MathUtils.clamp((state.handPos.x - 0.5) * dragRangeX * 2.2, -dragRangeX, dragRangeX)
          : 0;
        treeGroup.position.x = THREE.MathUtils.lerp(
          treeGroup.position.x,
          targetX,
          1 - Math.pow(0.001, dt)
        );

        // Hand rotation → scene rotation (smoothed)
        const targetY = state.handPresent ? state.handRotation * 0.65 : 0;
        treeGroup.rotation.y = THREE.MathUtils.lerp(
          treeGroup.rotation.y,
          targetY,
          1 - Math.pow(0.001, dt)
        );

        // subtle breathing to confirm render loop
        foliage.rotation.y += dt * 0.15;

        renderer.render(scene, camera);
      }

      setUiFromState();
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
